(*
 Autogenerated by Thrift

 DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING
*)

open Thrift
open Cassandra_types

(* HELPER FUNCTIONS AND STRUCTURES *)

class login_args =
object (self)
  val mutable _auth_request : authenticationRequest option = None
  method get_auth_request = _auth_request
  method grab_auth_request = match _auth_request with None->raise (Field_empty "login_args.auth_request") | Some _x238 -> _x238
  method set_auth_request _x238 = _auth_request <- Some _x238
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "login_args";
    (match _auth_request with None -> () | Some _v -> 
      oprot#writeFieldBegin("auth_request",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_login_args (iprot : Protocol.t) =
  let _str241 = new login_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t242,_id243) = iprot#readFieldBegin in
        if _t242 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id243 with 
          | 1 -> (if _t242 = Protocol.T_STRUCT then
              _str241#set_auth_request (read_authenticationRequest iprot)
            else
              iprot#skip _t242)
          | _ -> iprot#skip _t242);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str241

class login_result =
object (self)
  val mutable _success : AccessLevel.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "login_result.success") | Some _x244 -> _x244
  method set_success _x244 = _success <- Some _x244
  val mutable _authnx : authenticationException option = None
  method get_authnx = _authnx
  method grab_authnx = match _authnx with None->raise (Field_empty "login_result.authnx") | Some _x244 -> _x244
  method set_authnx _x244 = _authnx <- Some _x244
  val mutable _authzx : authorizationException option = None
  method get_authzx = _authzx
  method grab_authzx = match _authzx with None->raise (Field_empty "login_result.authzx") | Some _x244 -> _x244
  method set_authzx _x244 = _authzx <- Some _x244
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "login_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_I32,0);
      oprot#writeI32(AccessLevel.to_i _v);
      oprot#writeFieldEnd
    );
    (match _authnx with None -> () | Some _v -> 
      oprot#writeFieldBegin("authnx",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _authzx with None -> () | Some _v -> 
      oprot#writeFieldBegin("authzx",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_login_result (iprot : Protocol.t) =
  let _str247 = new login_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t248,_id249) = iprot#readFieldBegin in
        if _t248 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id249 with 
          | 0 -> (if _t248 = Protocol.T_I32 then
              _str247#set_success (AccessLevel.of_i iprot#readI32)
            else
              iprot#skip _t248)
          | 1 -> (if _t248 = Protocol.T_STRUCT then
              _str247#set_authnx (read_authenticationException iprot)
            else
              iprot#skip _t248)
          | 2 -> (if _t248 = Protocol.T_STRUCT then
              _str247#set_authzx (read_authorizationException iprot)
            else
              iprot#skip _t248)
          | _ -> iprot#skip _t248);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str247

class set_keyspace_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "set_keyspace_args.keyspace") | Some _x250 -> _x250
  method set_keyspace _x250 = _keyspace <- Some _x250
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "set_keyspace_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_set_keyspace_args (iprot : Protocol.t) =
  let _str253 = new set_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t254,_id255) = iprot#readFieldBegin in
        if _t254 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id255 with 
          | 1 -> (if _t254 = Protocol.T_STRING then
              _str253#set_keyspace iprot#readString
            else
              iprot#skip _t254)
          | _ -> iprot#skip _t254);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str253

class set_keyspace_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "set_keyspace_result.ire") | Some _x256 -> _x256
  method set_ire _x256 = _ire <- Some _x256
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "set_keyspace_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_set_keyspace_result (iprot : Protocol.t) =
  let _str259 = new set_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t260,_id261) = iprot#readFieldBegin in
        if _t260 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id261 with 
          | 1 -> (if _t260 = Protocol.T_STRUCT then
              _str259#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t260)
          | _ -> iprot#skip _t260);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str259

class get_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_args.key") | Some _x262 -> _x262
  method set_key _x262 = _key <- Some _x262
  val mutable _column_path : columnPath option = None
  method get_column_path = _column_path
  method grab_column_path = match _column_path with None->raise (Field_empty "get_args.column_path") | Some _x262 -> _x262
  method set_column_path _x262 = _column_path <- Some _x262
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "get_args.consistency_level") | Some _x262 -> _x262
  method set_consistency_level _x262 = _consistency_level <- Some _x262
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_args";
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_path with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_path",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,3);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_args (iprot : Protocol.t) =
  let _str265 = new get_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t266,_id267) = iprot#readFieldBegin in
        if _t266 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id267 with 
          | 1 -> (if _t266 = Protocol.T_STRING then
              _str265#set_key iprot#readString
            else
              iprot#skip _t266)
          | 2 -> (if _t266 = Protocol.T_STRUCT then
              _str265#set_column_path (read_columnPath iprot)
            else
              iprot#skip _t266)
          | 3 -> (if _t266 = Protocol.T_I32 then
              _str265#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t266)
          | _ -> iprot#skip _t266);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str265

class get_result =
object (self)
  val mutable _success : columnOrSuperColumn option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_result.success") | Some _x268 -> _x268
  method set_success _x268 = _success <- Some _x268
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_result.ire") | Some _x268 -> _x268
  method set_ire _x268 = _ire <- Some _x268
  val mutable _nfe : notFoundException option = None
  method get_nfe = _nfe
  method grab_nfe = match _nfe with None->raise (Field_empty "get_result.nfe") | Some _x268 -> _x268
  method set_nfe _x268 = _nfe <- Some _x268
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_result.ue") | Some _x268 -> _x268
  method set_ue _x268 = _ue <- Some _x268
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_result.te") | Some _x268 -> _x268
  method set_te _x268 = _te <- Some _x268
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRUCT,0);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _nfe with None -> () | Some _v -> 
      oprot#writeFieldBegin("nfe",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,4);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_result (iprot : Protocol.t) =
  let _str271 = new get_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t272,_id273) = iprot#readFieldBegin in
        if _t272 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id273 with 
          | 0 -> (if _t272 = Protocol.T_STRUCT then
              _str271#set_success (read_columnOrSuperColumn iprot)
            else
              iprot#skip _t272)
          | 1 -> (if _t272 = Protocol.T_STRUCT then
              _str271#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t272)
          | 2 -> (if _t272 = Protocol.T_STRUCT then
              _str271#set_nfe (read_notFoundException iprot)
            else
              iprot#skip _t272)
          | 3 -> (if _t272 = Protocol.T_STRUCT then
              _str271#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t272)
          | 4 -> (if _t272 = Protocol.T_STRUCT then
              _str271#set_te (read_timedOutException iprot)
            else
              iprot#skip _t272)
          | _ -> iprot#skip _t272);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str271

class get_slice_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_slice_args.key") | Some _x274 -> _x274
  method set_key _x274 = _key <- Some _x274
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_slice_args.column_parent") | Some _x274 -> _x274
  method set_column_parent _x274 = _column_parent <- Some _x274
  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "get_slice_args.predicate") | Some _x274 -> _x274
  method set_predicate _x274 = _predicate <- Some _x274
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "get_slice_args.consistency_level") | Some _x274 -> _x274
  method set_consistency_level _x274 = _consistency_level <- Some _x274
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_slice_args";
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with None -> () | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_slice_args (iprot : Protocol.t) =
  let _str277 = new get_slice_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t278,_id279) = iprot#readFieldBegin in
        if _t278 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id279 with 
          | 1 -> (if _t278 = Protocol.T_STRING then
              _str277#set_key iprot#readString
            else
              iprot#skip _t278)
          | 2 -> (if _t278 = Protocol.T_STRUCT then
              _str277#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t278)
          | 3 -> (if _t278 = Protocol.T_STRUCT then
              _str277#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t278)
          | 4 -> (if _t278 = Protocol.T_I32 then
              _str277#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t278)
          | _ -> iprot#skip _t278);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str277

class get_slice_result =
object (self)
  val mutable _success : columnOrSuperColumn list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_slice_result.success") | Some _x280 -> _x280
  method set_success _x280 = _success <- Some _x280
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_slice_result.ire") | Some _x280 -> _x280
  method set_ire _x280 = _ire <- Some _x280
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_slice_result.ue") | Some _x280 -> _x280
  method set_ue _x280 = _ue <- Some _x280
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_slice_result.te") | Some _x280 -> _x280
  method set_te _x280 = _te <- Some _x280
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_slice_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter283 ->         _iter283#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_slice_result (iprot : Protocol.t) =
  let _str284 = new get_slice_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t285,_id286) = iprot#readFieldBegin in
        if _t285 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id286 with 
          | 0 -> (if _t285 = Protocol.T_LIST then
              _str284#set_success 
                (let (_etype290,_size287) = iprot#readListBegin in
                  let _con291 = (Array.to_list (Array.init _size287 (fun _ -> (read_columnOrSuperColumn iprot)))) in
                    iprot#readListEnd; _con291)
            else
              iprot#skip _t285)
          | 1 -> (if _t285 = Protocol.T_STRUCT then
              _str284#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t285)
          | 2 -> (if _t285 = Protocol.T_STRUCT then
              _str284#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t285)
          | 3 -> (if _t285 = Protocol.T_STRUCT then
              _str284#set_te (read_timedOutException iprot)
            else
              iprot#skip _t285)
          | _ -> iprot#skip _t285);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str284

class get_count_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_count_args.key") | Some _x292 -> _x292
  method set_key _x292 = _key <- Some _x292
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_count_args.column_parent") | Some _x292 -> _x292
  method set_column_parent _x292 = _column_parent <- Some _x292
  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "get_count_args.predicate") | Some _x292 -> _x292
  method set_predicate _x292 = _predicate <- Some _x292
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "get_count_args.consistency_level") | Some _x292 -> _x292
  method set_consistency_level _x292 = _consistency_level <- Some _x292
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_count_args";
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with None -> () | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_count_args (iprot : Protocol.t) =
  let _str295 = new get_count_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t296,_id297) = iprot#readFieldBegin in
        if _t296 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id297 with 
          | 1 -> (if _t296 = Protocol.T_STRING then
              _str295#set_key iprot#readString
            else
              iprot#skip _t296)
          | 2 -> (if _t296 = Protocol.T_STRUCT then
              _str295#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t296)
          | 3 -> (if _t296 = Protocol.T_STRUCT then
              _str295#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t296)
          | 4 -> (if _t296 = Protocol.T_I32 then
              _str295#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t296)
          | _ -> iprot#skip _t296);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str295

class get_count_result =
object (self)
  val mutable _success : int option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_count_result.success") | Some _x298 -> _x298
  method set_success _x298 = _success <- Some _x298
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_count_result.ire") | Some _x298 -> _x298
  method set_ire _x298 = _ire <- Some _x298
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_count_result.ue") | Some _x298 -> _x298
  method set_ue _x298 = _ue <- Some _x298
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_count_result.te") | Some _x298 -> _x298
  method set_te _x298 = _te <- Some _x298
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_count_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_I32,0);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_count_result (iprot : Protocol.t) =
  let _str301 = new get_count_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t302,_id303) = iprot#readFieldBegin in
        if _t302 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id303 with 
          | 0 -> (if _t302 = Protocol.T_I32 then
              _str301#set_success iprot#readI32
            else
              iprot#skip _t302)
          | 1 -> (if _t302 = Protocol.T_STRUCT then
              _str301#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t302)
          | 2 -> (if _t302 = Protocol.T_STRUCT then
              _str301#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t302)
          | 3 -> (if _t302 = Protocol.T_STRUCT then
              _str301#set_te (read_timedOutException iprot)
            else
              iprot#skip _t302)
          | _ -> iprot#skip _t302);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str301

class multiget_slice_args =
object (self)
  val mutable _keys : string list option = None
  method get_keys = _keys
  method grab_keys = match _keys with None->raise (Field_empty "multiget_slice_args.keys") | Some _x304 -> _x304
  method set_keys _x304 = _keys <- Some _x304
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "multiget_slice_args.column_parent") | Some _x304 -> _x304
  method set_column_parent _x304 = _column_parent <- Some _x304
  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "multiget_slice_args.predicate") | Some _x304 -> _x304
  method set_predicate _x304 = _predicate <- Some _x304
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "multiget_slice_args.consistency_level") | Some _x304 -> _x304
  method set_consistency_level _x304 = _consistency_level <- Some _x304
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_slice_args";
    (match _keys with None -> () | Some _v -> 
      oprot#writeFieldBegin("keys",Protocol.T_LIST,1);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter307 ->         oprot#writeString(_iter307);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with None -> () | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_slice_args (iprot : Protocol.t) =
  let _str308 = new multiget_slice_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t309,_id310) = iprot#readFieldBegin in
        if _t309 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id310 with 
          | 1 -> (if _t309 = Protocol.T_LIST then
              _str308#set_keys 
                (let (_etype314,_size311) = iprot#readListBegin in
                  let _con315 = (Array.to_list (Array.init _size311 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con315)
            else
              iprot#skip _t309)
          | 2 -> (if _t309 = Protocol.T_STRUCT then
              _str308#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t309)
          | 3 -> (if _t309 = Protocol.T_STRUCT then
              _str308#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t309)
          | 4 -> (if _t309 = Protocol.T_I32 then
              _str308#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t309)
          | _ -> iprot#skip _t309);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str308

class multiget_slice_result =
object (self)
  val mutable _success : (string,columnOrSuperColumn list) Hashtbl.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "multiget_slice_result.success") | Some _x316 -> _x316
  method set_success _x316 = _success <- Some _x316
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "multiget_slice_result.ire") | Some _x316 -> _x316
  method set_ire _x316 = _ire <- Some _x316
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "multiget_slice_result.ue") | Some _x316 -> _x316
  method set_ue _x316 = _ue <- Some _x316
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "multiget_slice_result.te") | Some _x316 -> _x316
  method set_te _x316 = _te <- Some _x316
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_slice_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_MAP,0);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_LIST,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter319 -> fun _viter320 -> 
        oprot#writeString(_kiter319);
        oprot#writeListBegin(Protocol.T_STRUCT,List.length _viter320);
        List.iter (fun _iter321 ->           _iter321#write(oprot);
        ) _viter320;
        oprot#writeListEnd;
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_slice_result (iprot : Protocol.t) =
  let _str322 = new multiget_slice_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t323,_id324) = iprot#readFieldBegin in
        if _t323 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id324 with 
          | 0 -> (if _t323 = Protocol.T_MAP then
              _str322#set_success 
                (let (_ktype326,_vtype327,_size325) = iprot#readMapBegin in
                let _con329 = Hashtbl.create _size325 in
                  for i = 1 to _size325 do
                    let _k = iprot#readString in
                    let _v = 
                      (let (_etype333,_size330) = iprot#readListBegin in
                        let _con334 = (Array.to_list (Array.init _size330 (fun _ -> (read_columnOrSuperColumn iprot)))) in
                          iprot#readListEnd; _con334) in
                      Hashtbl.add _con329 _k _v
                  done; iprot#readMapEnd; _con329)
            else
              iprot#skip _t323)
          | 1 -> (if _t323 = Protocol.T_STRUCT then
              _str322#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t323)
          | 2 -> (if _t323 = Protocol.T_STRUCT then
              _str322#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t323)
          | 3 -> (if _t323 = Protocol.T_STRUCT then
              _str322#set_te (read_timedOutException iprot)
            else
              iprot#skip _t323)
          | _ -> iprot#skip _t323);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str322

class multiget_count_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "multiget_count_args.keyspace") | Some _x335 -> _x335
  method set_keyspace _x335 = _keyspace <- Some _x335
  val mutable _keys : string list option = None
  method get_keys = _keys
  method grab_keys = match _keys with None->raise (Field_empty "multiget_count_args.keys") | Some _x335 -> _x335
  method set_keys _x335 = _keys <- Some _x335
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "multiget_count_args.column_parent") | Some _x335 -> _x335
  method set_column_parent _x335 = _column_parent <- Some _x335
  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "multiget_count_args.predicate") | Some _x335 -> _x335
  method set_predicate _x335 = _predicate <- Some _x335
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "multiget_count_args.consistency_level") | Some _x335 -> _x335
  method set_consistency_level _x335 = _consistency_level <- Some _x335
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_count_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _keys with None -> () | Some _v -> 
      oprot#writeFieldBegin("keys",Protocol.T_LIST,2);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter338 ->         oprot#writeString(_iter338);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with None -> () | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,4);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,5);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_count_args (iprot : Protocol.t) =
  let _str339 = new multiget_count_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t340,_id341) = iprot#readFieldBegin in
        if _t340 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id341 with 
          | 1 -> (if _t340 = Protocol.T_STRING then
              _str339#set_keyspace iprot#readString
            else
              iprot#skip _t340)
          | 2 -> (if _t340 = Protocol.T_LIST then
              _str339#set_keys 
                (let (_etype345,_size342) = iprot#readListBegin in
                  let _con346 = (Array.to_list (Array.init _size342 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con346)
            else
              iprot#skip _t340)
          | 3 -> (if _t340 = Protocol.T_STRUCT then
              _str339#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t340)
          | 4 -> (if _t340 = Protocol.T_STRUCT then
              _str339#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t340)
          | 5 -> (if _t340 = Protocol.T_I32 then
              _str339#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t340)
          | _ -> iprot#skip _t340);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str339

class multiget_count_result =
object (self)
  val mutable _success : (string,int) Hashtbl.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "multiget_count_result.success") | Some _x347 -> _x347
  method set_success _x347 = _success <- Some _x347
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "multiget_count_result.ire") | Some _x347 -> _x347
  method set_ire _x347 = _ire <- Some _x347
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "multiget_count_result.ue") | Some _x347 -> _x347
  method set_ue _x347 = _ue <- Some _x347
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "multiget_count_result.te") | Some _x347 -> _x347
  method set_te _x347 = _te <- Some _x347
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_count_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_MAP,0);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_I32,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter350 -> fun _viter351 -> 
        oprot#writeString(_kiter350);
        oprot#writeI32(_viter351);
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_count_result (iprot : Protocol.t) =
  let _str352 = new multiget_count_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t353,_id354) = iprot#readFieldBegin in
        if _t353 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id354 with 
          | 0 -> (if _t353 = Protocol.T_MAP then
              _str352#set_success 
                (let (_ktype356,_vtype357,_size355) = iprot#readMapBegin in
                let _con359 = Hashtbl.create _size355 in
                  for i = 1 to _size355 do
                    let _k = iprot#readString in
                    let _v = iprot#readI32 in
                      Hashtbl.add _con359 _k _v
                  done; iprot#readMapEnd; _con359)
            else
              iprot#skip _t353)
          | 1 -> (if _t353 = Protocol.T_STRUCT then
              _str352#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t353)
          | 2 -> (if _t353 = Protocol.T_STRUCT then
              _str352#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t353)
          | 3 -> (if _t353 = Protocol.T_STRUCT then
              _str352#set_te (read_timedOutException iprot)
            else
              iprot#skip _t353)
          | _ -> iprot#skip _t353);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str352

class get_range_slices_args =
object (self)
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_range_slices_args.column_parent") | Some _x360 -> _x360
  method set_column_parent _x360 = _column_parent <- Some _x360
  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "get_range_slices_args.predicate") | Some _x360 -> _x360
  method set_predicate _x360 = _predicate <- Some _x360
  val mutable _range : keyRange option = None
  method get_range = _range
  method grab_range = match _range with None->raise (Field_empty "get_range_slices_args.range") | Some _x360 -> _x360
  method set_range _x360 = _range <- Some _x360
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "get_range_slices_args.consistency_level") | Some _x360 -> _x360
  method set_consistency_level _x360 = _consistency_level <- Some _x360
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_range_slices_args";
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with None -> () | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _range with None -> () | Some _v -> 
      oprot#writeFieldBegin("range",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_range_slices_args (iprot : Protocol.t) =
  let _str363 = new get_range_slices_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t364,_id365) = iprot#readFieldBegin in
        if _t364 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id365 with 
          | 1 -> (if _t364 = Protocol.T_STRUCT then
              _str363#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t364)
          | 2 -> (if _t364 = Protocol.T_STRUCT then
              _str363#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t364)
          | 3 -> (if _t364 = Protocol.T_STRUCT then
              _str363#set_range (read_keyRange iprot)
            else
              iprot#skip _t364)
          | 4 -> (if _t364 = Protocol.T_I32 then
              _str363#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t364)
          | _ -> iprot#skip _t364);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str363

class get_range_slices_result =
object (self)
  val mutable _success : keySlice list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_range_slices_result.success") | Some _x366 -> _x366
  method set_success _x366 = _success <- Some _x366
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_range_slices_result.ire") | Some _x366 -> _x366
  method set_ire _x366 = _ire <- Some _x366
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_range_slices_result.ue") | Some _x366 -> _x366
  method set_ue _x366 = _ue <- Some _x366
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_range_slices_result.te") | Some _x366 -> _x366
  method set_te _x366 = _te <- Some _x366
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_range_slices_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter369 ->         _iter369#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_range_slices_result (iprot : Protocol.t) =
  let _str370 = new get_range_slices_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t371,_id372) = iprot#readFieldBegin in
        if _t371 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id372 with 
          | 0 -> (if _t371 = Protocol.T_LIST then
              _str370#set_success 
                (let (_etype376,_size373) = iprot#readListBegin in
                  let _con377 = (Array.to_list (Array.init _size373 (fun _ -> (read_keySlice iprot)))) in
                    iprot#readListEnd; _con377)
            else
              iprot#skip _t371)
          | 1 -> (if _t371 = Protocol.T_STRUCT then
              _str370#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t371)
          | 2 -> (if _t371 = Protocol.T_STRUCT then
              _str370#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t371)
          | 3 -> (if _t371 = Protocol.T_STRUCT then
              _str370#set_te (read_timedOutException iprot)
            else
              iprot#skip _t371)
          | _ -> iprot#skip _t371);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str370

class get_indexed_slices_args =
object (self)
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_indexed_slices_args.column_parent") | Some _x378 -> _x378
  method set_column_parent _x378 = _column_parent <- Some _x378
  val mutable _index_clause : indexClause option = None
  method get_index_clause = _index_clause
  method grab_index_clause = match _index_clause with None->raise (Field_empty "get_indexed_slices_args.index_clause") | Some _x378 -> _x378
  method set_index_clause _x378 = _index_clause <- Some _x378
  val mutable _column_predicate : slicePredicate option = None
  method get_column_predicate = _column_predicate
  method grab_column_predicate = match _column_predicate with None->raise (Field_empty "get_indexed_slices_args.column_predicate") | Some _x378 -> _x378
  method set_column_predicate _x378 = _column_predicate <- Some _x378
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "get_indexed_slices_args.consistency_level") | Some _x378 -> _x378
  method set_consistency_level _x378 = _consistency_level <- Some _x378
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_indexed_slices_args";
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _index_clause with None -> () | Some _v -> 
      oprot#writeFieldBegin("index_clause",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _column_predicate with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_indexed_slices_args (iprot : Protocol.t) =
  let _str381 = new get_indexed_slices_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t382,_id383) = iprot#readFieldBegin in
        if _t382 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id383 with 
          | 1 -> (if _t382 = Protocol.T_STRUCT then
              _str381#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t382)
          | 2 -> (if _t382 = Protocol.T_STRUCT then
              _str381#set_index_clause (read_indexClause iprot)
            else
              iprot#skip _t382)
          | 3 -> (if _t382 = Protocol.T_STRUCT then
              _str381#set_column_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t382)
          | 4 -> (if _t382 = Protocol.T_I32 then
              _str381#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t382)
          | _ -> iprot#skip _t382);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str381

class get_indexed_slices_result =
object (self)
  val mutable _success : keySlice list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_indexed_slices_result.success") | Some _x384 -> _x384
  method set_success _x384 = _success <- Some _x384
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_indexed_slices_result.ire") | Some _x384 -> _x384
  method set_ire _x384 = _ire <- Some _x384
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_indexed_slices_result.ue") | Some _x384 -> _x384
  method set_ue _x384 = _ue <- Some _x384
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_indexed_slices_result.te") | Some _x384 -> _x384
  method set_te _x384 = _te <- Some _x384
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_indexed_slices_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter387 ->         _iter387#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_indexed_slices_result (iprot : Protocol.t) =
  let _str388 = new get_indexed_slices_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t389,_id390) = iprot#readFieldBegin in
        if _t389 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id390 with 
          | 0 -> (if _t389 = Protocol.T_LIST then
              _str388#set_success 
                (let (_etype394,_size391) = iprot#readListBegin in
                  let _con395 = (Array.to_list (Array.init _size391 (fun _ -> (read_keySlice iprot)))) in
                    iprot#readListEnd; _con395)
            else
              iprot#skip _t389)
          | 1 -> (if _t389 = Protocol.T_STRUCT then
              _str388#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t389)
          | 2 -> (if _t389 = Protocol.T_STRUCT then
              _str388#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t389)
          | 3 -> (if _t389 = Protocol.T_STRUCT then
              _str388#set_te (read_timedOutException iprot)
            else
              iprot#skip _t389)
          | _ -> iprot#skip _t389);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str388

class insert_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "insert_args.key") | Some _x396 -> _x396
  method set_key _x396 = _key <- Some _x396
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "insert_args.column_parent") | Some _x396 -> _x396
  method set_column_parent _x396 = _column_parent <- Some _x396
  val mutable _column : column option = None
  method get_column = _column
  method grab_column = match _column with None->raise (Field_empty "insert_args.column") | Some _x396 -> _x396
  method set_column _x396 = _column <- Some _x396
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "insert_args.consistency_level") | Some _x396 -> _x396
  method set_consistency_level _x396 = _consistency_level <- Some _x396
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "insert_args";
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_parent with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _column with None -> () | Some _v -> 
      oprot#writeFieldBegin("column",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_insert_args (iprot : Protocol.t) =
  let _str399 = new insert_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t400,_id401) = iprot#readFieldBegin in
        if _t400 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id401 with 
          | 1 -> (if _t400 = Protocol.T_STRING then
              _str399#set_key iprot#readString
            else
              iprot#skip _t400)
          | 2 -> (if _t400 = Protocol.T_STRUCT then
              _str399#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t400)
          | 3 -> (if _t400 = Protocol.T_STRUCT then
              _str399#set_column (read_column iprot)
            else
              iprot#skip _t400)
          | 4 -> (if _t400 = Protocol.T_I32 then
              _str399#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t400)
          | _ -> iprot#skip _t400);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str399

class insert_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "insert_result.ire") | Some _x402 -> _x402
  method set_ire _x402 = _ire <- Some _x402
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "insert_result.ue") | Some _x402 -> _x402
  method set_ue _x402 = _ue <- Some _x402
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "insert_result.te") | Some _x402 -> _x402
  method set_te _x402 = _te <- Some _x402
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "insert_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_insert_result (iprot : Protocol.t) =
  let _str405 = new insert_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t406,_id407) = iprot#readFieldBegin in
        if _t406 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id407 with 
          | 1 -> (if _t406 = Protocol.T_STRUCT then
              _str405#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t406)
          | 2 -> (if _t406 = Protocol.T_STRUCT then
              _str405#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t406)
          | 3 -> (if _t406 = Protocol.T_STRUCT then
              _str405#set_te (read_timedOutException iprot)
            else
              iprot#skip _t406)
          | _ -> iprot#skip _t406);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str405

class remove_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "remove_args.key") | Some _x408 -> _x408
  method set_key _x408 = _key <- Some _x408
  val mutable _column_path : columnPath option = None
  method get_column_path = _column_path
  method grab_column_path = match _column_path with None->raise (Field_empty "remove_args.column_path") | Some _x408 -> _x408
  method set_column_path _x408 = _column_path <- Some _x408
  val mutable _clock : clock option = None
  method get_clock = _clock
  method grab_clock = match _clock with None->raise (Field_empty "remove_args.clock") | Some _x408 -> _x408
  method set_clock _x408 = _clock <- Some _x408
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "remove_args.consistency_level") | Some _x408 -> _x408
  method set_consistency_level _x408 = _consistency_level <- Some _x408
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "remove_args";
    (match _key with None -> () | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_path with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_path",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _clock with None -> () | Some _v -> 
      oprot#writeFieldBegin("clock",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_remove_args (iprot : Protocol.t) =
  let _str411 = new remove_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t412,_id413) = iprot#readFieldBegin in
        if _t412 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id413 with 
          | 1 -> (if _t412 = Protocol.T_STRING then
              _str411#set_key iprot#readString
            else
              iprot#skip _t412)
          | 2 -> (if _t412 = Protocol.T_STRUCT then
              _str411#set_column_path (read_columnPath iprot)
            else
              iprot#skip _t412)
          | 3 -> (if _t412 = Protocol.T_STRUCT then
              _str411#set_clock (read_clock iprot)
            else
              iprot#skip _t412)
          | 4 -> (if _t412 = Protocol.T_I32 then
              _str411#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t412)
          | _ -> iprot#skip _t412);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str411

class remove_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "remove_result.ire") | Some _x414 -> _x414
  method set_ire _x414 = _ire <- Some _x414
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "remove_result.ue") | Some _x414 -> _x414
  method set_ue _x414 = _ue <- Some _x414
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "remove_result.te") | Some _x414 -> _x414
  method set_te _x414 = _te <- Some _x414
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "remove_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_remove_result (iprot : Protocol.t) =
  let _str417 = new remove_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t418,_id419) = iprot#readFieldBegin in
        if _t418 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id419 with 
          | 1 -> (if _t418 = Protocol.T_STRUCT then
              _str417#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t418)
          | 2 -> (if _t418 = Protocol.T_STRUCT then
              _str417#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t418)
          | 3 -> (if _t418 = Protocol.T_STRUCT then
              _str417#set_te (read_timedOutException iprot)
            else
              iprot#skip _t418)
          | _ -> iprot#skip _t418);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str417

class batch_mutate_args =
object (self)
  val mutable _mutation_map : (string,(string,mutation list) Hashtbl.t) Hashtbl.t option = None
  method get_mutation_map = _mutation_map
  method grab_mutation_map = match _mutation_map with None->raise (Field_empty "batch_mutate_args.mutation_map") | Some _x420 -> _x420
  method set_mutation_map _x420 = _mutation_map <- Some _x420
  val mutable _consistency_level : ConsistencyLevel.t option = None
  method get_consistency_level = _consistency_level
  method grab_consistency_level = match _consistency_level with None->raise (Field_empty "batch_mutate_args.consistency_level") | Some _x420 -> _x420
  method set_consistency_level _x420 = _consistency_level <- Some _x420
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_mutate_args";
    (match _mutation_map with None -> () | Some _v -> 
      oprot#writeFieldBegin("mutation_map",Protocol.T_MAP,1);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_MAP,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter423 -> fun _viter424 -> 
        oprot#writeString(_kiter423);
        oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_LIST,Hashtbl.length _viter424);
        Hashtbl.iter (fun _kiter425 -> fun _viter426 -> 
          oprot#writeString(_kiter425);
          oprot#writeListBegin(Protocol.T_STRUCT,List.length _viter426);
          List.iter (fun _iter427 ->             _iter427#write(oprot);
          ) _viter426;
          oprot#writeListEnd;
        ) _viter424;
        oprot#writeMapEnd;
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _consistency_level with None -> () | Some _v -> 
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,2);
      oprot#writeI32(ConsistencyLevel.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_mutate_args (iprot : Protocol.t) =
  let _str428 = new batch_mutate_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t429,_id430) = iprot#readFieldBegin in
        if _t429 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id430 with 
          | 1 -> (if _t429 = Protocol.T_MAP then
              _str428#set_mutation_map 
                (let (_ktype432,_vtype433,_size431) = iprot#readMapBegin in
                let _con435 = Hashtbl.create _size431 in
                  for i = 1 to _size431 do
                    let _k = iprot#readString in
                    let _v = 
                      (let (_ktype437,_vtype438,_size436) = iprot#readMapBegin in
                      let _con440 = Hashtbl.create _size436 in
                        for i = 1 to _size436 do
                          let _k = iprot#readString in
                          let _v = 
                            (let (_etype444,_size441) = iprot#readListBegin in
                              let _con445 = (Array.to_list (Array.init _size441 (fun _ -> (read_mutation iprot)))) in
                                iprot#readListEnd; _con445) in
                            Hashtbl.add _con440 _k _v
                        done; iprot#readMapEnd; _con440) in
                      Hashtbl.add _con435 _k _v
                  done; iprot#readMapEnd; _con435)
            else
              iprot#skip _t429)
          | 2 -> (if _t429 = Protocol.T_I32 then
              _str428#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t429)
          | _ -> iprot#skip _t429);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str428

class batch_mutate_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "batch_mutate_result.ire") | Some _x446 -> _x446
  method set_ire _x446 = _ire <- Some _x446
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "batch_mutate_result.ue") | Some _x446 -> _x446
  method set_ue _x446 = _ue <- Some _x446
  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "batch_mutate_result.te") | Some _x446 -> _x446
  method set_te _x446 = _te <- Some _x446
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_mutate_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_mutate_result (iprot : Protocol.t) =
  let _str449 = new batch_mutate_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t450,_id451) = iprot#readFieldBegin in
        if _t450 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id451 with 
          | 1 -> (if _t450 = Protocol.T_STRUCT then
              _str449#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t450)
          | 2 -> (if _t450 = Protocol.T_STRUCT then
              _str449#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t450)
          | 3 -> (if _t450 = Protocol.T_STRUCT then
              _str449#set_te (read_timedOutException iprot)
            else
              iprot#skip _t450)
          | _ -> iprot#skip _t450);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str449

class truncate_args =
object (self)
  val mutable _cfname : string option = None
  method get_cfname = _cfname
  method grab_cfname = match _cfname with None->raise (Field_empty "truncate_args.cfname") | Some _x452 -> _x452
  method set_cfname _x452 = _cfname <- Some _x452
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "truncate_args";
    (match _cfname with None -> () | Some _v -> 
      oprot#writeFieldBegin("cfname",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_truncate_args (iprot : Protocol.t) =
  let _str455 = new truncate_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t456,_id457) = iprot#readFieldBegin in
        if _t456 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id457 with 
          | 1 -> (if _t456 = Protocol.T_STRING then
              _str455#set_cfname iprot#readString
            else
              iprot#skip _t456)
          | _ -> iprot#skip _t456);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str455

class truncate_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "truncate_result.ire") | Some _x458 -> _x458
  method set_ire _x458 = _ire <- Some _x458
  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "truncate_result.ue") | Some _x458 -> _x458
  method set_ue _x458 = _ue <- Some _x458
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "truncate_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_truncate_result (iprot : Protocol.t) =
  let _str461 = new truncate_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t462,_id463) = iprot#readFieldBegin in
        if _t462 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id463 with 
          | 1 -> (if _t462 = Protocol.T_STRUCT then
              _str461#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t462)
          | 2 -> (if _t462 = Protocol.T_STRUCT then
              _str461#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t462)
          | _ -> iprot#skip _t462);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str461

class check_schema_agreement_args =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "check_schema_agreement_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_check_schema_agreement_args (iprot : Protocol.t) =
  let _str467 = new check_schema_agreement_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t468,_id469) = iprot#readFieldBegin in
        if _t468 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id469 with 
          | _ -> iprot#skip _t468);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str467

class check_schema_agreement_result =
object (self)
  val mutable _success : (string,string list) Hashtbl.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "check_schema_agreement_result.success") | Some _x470 -> _x470
  method set_success _x470 = _success <- Some _x470
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "check_schema_agreement_result.ire") | Some _x470 -> _x470
  method set_ire _x470 = _ire <- Some _x470
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "check_schema_agreement_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_MAP,0);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_LIST,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter473 -> fun _viter474 -> 
        oprot#writeString(_kiter473);
        oprot#writeListBegin(Protocol.T_STRING,List.length _viter474);
        List.iter (fun _iter475 ->           oprot#writeString(_iter475);
        ) _viter474;
        oprot#writeListEnd;
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_check_schema_agreement_result (iprot : Protocol.t) =
  let _str476 = new check_schema_agreement_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t477,_id478) = iprot#readFieldBegin in
        if _t477 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id478 with 
          | 0 -> (if _t477 = Protocol.T_MAP then
              _str476#set_success 
                (let (_ktype480,_vtype481,_size479) = iprot#readMapBegin in
                let _con483 = Hashtbl.create _size479 in
                  for i = 1 to _size479 do
                    let _k = iprot#readString in
                    let _v = 
                      (let (_etype487,_size484) = iprot#readListBegin in
                        let _con488 = (Array.to_list (Array.init _size484 (fun _ -> iprot#readString))) in
                          iprot#readListEnd; _con488) in
                      Hashtbl.add _con483 _k _v
                  done; iprot#readMapEnd; _con483)
            else
              iprot#skip _t477)
          | 1 -> (if _t477 = Protocol.T_STRUCT then
              _str476#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t477)
          | _ -> iprot#skip _t477);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str476

class describe_keyspaces_args =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_keyspaces_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_keyspaces_args (iprot : Protocol.t) =
  let _str492 = new describe_keyspaces_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t493,_id494) = iprot#readFieldBegin in
        if _t493 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id494 with 
          | _ -> iprot#skip _t493);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str492

class describe_keyspaces_result =
object (self)
  val mutable _success : ksDef list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_keyspaces_result.success") | Some _x495 -> _x495
  method set_success _x495 = _success <- Some _x495
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_keyspaces_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter498 ->         _iter498#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_keyspaces_result (iprot : Protocol.t) =
  let _str499 = new describe_keyspaces_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t500,_id501) = iprot#readFieldBegin in
        if _t500 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id501 with 
          | 0 -> (if _t500 = Protocol.T_LIST then
              _str499#set_success 
                (let (_etype505,_size502) = iprot#readListBegin in
                  let _con506 = (Array.to_list (Array.init _size502 (fun _ -> (read_ksDef iprot)))) in
                    iprot#readListEnd; _con506)
            else
              iprot#skip _t500)
          | _ -> iprot#skip _t500);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str499

class describe_cluster_name_args =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_cluster_name_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_cluster_name_args (iprot : Protocol.t) =
  let _str510 = new describe_cluster_name_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t511,_id512) = iprot#readFieldBegin in
        if _t511 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id512 with 
          | _ -> iprot#skip _t511);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str510

class describe_cluster_name_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_cluster_name_result.success") | Some _x513 -> _x513
  method set_success _x513 = _success <- Some _x513
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_cluster_name_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_cluster_name_result (iprot : Protocol.t) =
  let _str516 = new describe_cluster_name_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t517,_id518) = iprot#readFieldBegin in
        if _t517 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id518 with 
          | 0 -> (if _t517 = Protocol.T_STRING then
              _str516#set_success iprot#readString
            else
              iprot#skip _t517)
          | _ -> iprot#skip _t517);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str516

class describe_version_args =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_version_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_version_args (iprot : Protocol.t) =
  let _str522 = new describe_version_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t523,_id524) = iprot#readFieldBegin in
        if _t523 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id524 with 
          | _ -> iprot#skip _t523);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str522

class describe_version_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_version_result.success") | Some _x525 -> _x525
  method set_success _x525 = _success <- Some _x525
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_version_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_version_result (iprot : Protocol.t) =
  let _str528 = new describe_version_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t529,_id530) = iprot#readFieldBegin in
        if _t529 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id530 with 
          | 0 -> (if _t529 = Protocol.T_STRING then
              _str528#set_success iprot#readString
            else
              iprot#skip _t529)
          | _ -> iprot#skip _t529);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str528

class describe_ring_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "describe_ring_args.keyspace") | Some _x531 -> _x531
  method set_keyspace _x531 = _keyspace <- Some _x531
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_ring_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_ring_args (iprot : Protocol.t) =
  let _str534 = new describe_ring_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t535,_id536) = iprot#readFieldBegin in
        if _t535 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id536 with 
          | 1 -> (if _t535 = Protocol.T_STRING then
              _str534#set_keyspace iprot#readString
            else
              iprot#skip _t535)
          | _ -> iprot#skip _t535);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str534

class describe_ring_result =
object (self)
  val mutable _success : tokenRange list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_ring_result.success") | Some _x537 -> _x537
  method set_success _x537 = _success <- Some _x537
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "describe_ring_result.ire") | Some _x537 -> _x537
  method set_ire _x537 = _ire <- Some _x537
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_ring_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter540 ->         _iter540#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_ring_result (iprot : Protocol.t) =
  let _str541 = new describe_ring_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t542,_id543) = iprot#readFieldBegin in
        if _t542 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id543 with 
          | 0 -> (if _t542 = Protocol.T_LIST then
              _str541#set_success 
                (let (_etype547,_size544) = iprot#readListBegin in
                  let _con548 = (Array.to_list (Array.init _size544 (fun _ -> (read_tokenRange iprot)))) in
                    iprot#readListEnd; _con548)
            else
              iprot#skip _t542)
          | 1 -> (if _t542 = Protocol.T_STRUCT then
              _str541#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t542)
          | _ -> iprot#skip _t542);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str541

class describe_partitioner_args =
object (self)
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_partitioner_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_partitioner_args (iprot : Protocol.t) =
  let _str552 = new describe_partitioner_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t553,_id554) = iprot#readFieldBegin in
        if _t553 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id554 with 
          | _ -> iprot#skip _t553);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str552

class describe_partitioner_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_partitioner_result.success") | Some _x555 -> _x555
  method set_success _x555 = _success <- Some _x555
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_partitioner_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_partitioner_result (iprot : Protocol.t) =
  let _str558 = new describe_partitioner_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t559,_id560) = iprot#readFieldBegin in
        if _t559 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id560 with 
          | 0 -> (if _t559 = Protocol.T_STRING then
              _str558#set_success iprot#readString
            else
              iprot#skip _t559)
          | _ -> iprot#skip _t559);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str558

class describe_keyspace_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "describe_keyspace_args.keyspace") | Some _x561 -> _x561
  method set_keyspace _x561 = _keyspace <- Some _x561
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_keyspace_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_keyspace_args (iprot : Protocol.t) =
  let _str564 = new describe_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t565,_id566) = iprot#readFieldBegin in
        if _t565 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id566 with 
          | 1 -> (if _t565 = Protocol.T_STRING then
              _str564#set_keyspace iprot#readString
            else
              iprot#skip _t565)
          | _ -> iprot#skip _t565);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str564

class describe_keyspace_result =
object (self)
  val mutable _success : ksDef option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_keyspace_result.success") | Some _x567 -> _x567
  method set_success _x567 = _success <- Some _x567
  val mutable _nfe : notFoundException option = None
  method get_nfe = _nfe
  method grab_nfe = match _nfe with None->raise (Field_empty "describe_keyspace_result.nfe") | Some _x567 -> _x567
  method set_nfe _x567 = _nfe <- Some _x567
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_keyspace_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRUCT,0);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _nfe with None -> () | Some _v -> 
      oprot#writeFieldBegin("nfe",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_keyspace_result (iprot : Protocol.t) =
  let _str570 = new describe_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t571,_id572) = iprot#readFieldBegin in
        if _t571 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id572 with 
          | 0 -> (if _t571 = Protocol.T_STRUCT then
              _str570#set_success (read_ksDef iprot)
            else
              iprot#skip _t571)
          | 1 -> (if _t571 = Protocol.T_STRUCT then
              _str570#set_nfe (read_notFoundException iprot)
            else
              iprot#skip _t571)
          | _ -> iprot#skip _t571);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str570

class describe_splits_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "describe_splits_args.keyspace") | Some _x573 -> _x573
  method set_keyspace _x573 = _keyspace <- Some _x573
  val mutable _cfName : string option = None
  method get_cfName = _cfName
  method grab_cfName = match _cfName with None->raise (Field_empty "describe_splits_args.cfName") | Some _x573 -> _x573
  method set_cfName _x573 = _cfName <- Some _x573
  val mutable _start_token : string option = None
  method get_start_token = _start_token
  method grab_start_token = match _start_token with None->raise (Field_empty "describe_splits_args.start_token") | Some _x573 -> _x573
  method set_start_token _x573 = _start_token <- Some _x573
  val mutable _end_token : string option = None
  method get_end_token = _end_token
  method grab_end_token = match _end_token with None->raise (Field_empty "describe_splits_args.end_token") | Some _x573 -> _x573
  method set_end_token _x573 = _end_token <- Some _x573
  val mutable _keys_per_split : int option = None
  method get_keys_per_split = _keys_per_split
  method grab_keys_per_split = match _keys_per_split with None->raise (Field_empty "describe_splits_args.keys_per_split") | Some _x573 -> _x573
  method set_keys_per_split _x573 = _keys_per_split <- Some _x573
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_splits_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _cfName with None -> () | Some _v -> 
      oprot#writeFieldBegin("cfName",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _start_token with None -> () | Some _v -> 
      oprot#writeFieldBegin("start_token",Protocol.T_STRING,3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _end_token with None -> () | Some _v -> 
      oprot#writeFieldBegin("end_token",Protocol.T_STRING,4);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _keys_per_split with None -> () | Some _v -> 
      oprot#writeFieldBegin("keys_per_split",Protocol.T_I32,5);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_splits_args (iprot : Protocol.t) =
  let _str576 = new describe_splits_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t577,_id578) = iprot#readFieldBegin in
        if _t577 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id578 with 
          | 1 -> (if _t577 = Protocol.T_STRING then
              _str576#set_keyspace iprot#readString
            else
              iprot#skip _t577)
          | 2 -> (if _t577 = Protocol.T_STRING then
              _str576#set_cfName iprot#readString
            else
              iprot#skip _t577)
          | 3 -> (if _t577 = Protocol.T_STRING then
              _str576#set_start_token iprot#readString
            else
              iprot#skip _t577)
          | 4 -> (if _t577 = Protocol.T_STRING then
              _str576#set_end_token iprot#readString
            else
              iprot#skip _t577)
          | 5 -> (if _t577 = Protocol.T_I32 then
              _str576#set_keys_per_split iprot#readI32
            else
              iprot#skip _t577)
          | _ -> iprot#skip _t577);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str576

class describe_splits_result =
object (self)
  val mutable _success : string list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_splits_result.success") | Some _x579 -> _x579
  method set_success _x579 = _success <- Some _x579
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_splits_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter582 ->         oprot#writeString(_iter582);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_splits_result (iprot : Protocol.t) =
  let _str583 = new describe_splits_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t584,_id585) = iprot#readFieldBegin in
        if _t584 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id585 with 
          | 0 -> (if _t584 = Protocol.T_LIST then
              _str583#set_success 
                (let (_etype589,_size586) = iprot#readListBegin in
                  let _con590 = (Array.to_list (Array.init _size586 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con590)
            else
              iprot#skip _t584)
          | _ -> iprot#skip _t584);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str583

class system_add_column_family_args =
object (self)
  val mutable _cf_def : cfDef option = None
  method get_cf_def = _cf_def
  method grab_cf_def = match _cf_def with None->raise (Field_empty "system_add_column_family_args.cf_def") | Some _x591 -> _x591
  method set_cf_def _x591 = _cf_def <- Some _x591
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_add_column_family_args";
    (match _cf_def with None -> () | Some _v -> 
      oprot#writeFieldBegin("cf_def",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_add_column_family_args (iprot : Protocol.t) =
  let _str594 = new system_add_column_family_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t595,_id596) = iprot#readFieldBegin in
        if _t595 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id596 with 
          | 1 -> (if _t595 = Protocol.T_STRUCT then
              _str594#set_cf_def (read_cfDef iprot)
            else
              iprot#skip _t595)
          | _ -> iprot#skip _t595);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str594

class system_add_column_family_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_add_column_family_result.success") | Some _x597 -> _x597
  method set_success _x597 = _success <- Some _x597
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_add_column_family_result.ire") | Some _x597 -> _x597
  method set_ire _x597 = _ire <- Some _x597
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_add_column_family_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_add_column_family_result (iprot : Protocol.t) =
  let _str600 = new system_add_column_family_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t601,_id602) = iprot#readFieldBegin in
        if _t601 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id602 with 
          | 0 -> (if _t601 = Protocol.T_STRING then
              _str600#set_success iprot#readString
            else
              iprot#skip _t601)
          | 1 -> (if _t601 = Protocol.T_STRUCT then
              _str600#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t601)
          | _ -> iprot#skip _t601);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str600

class system_drop_column_family_args =
object (self)
  val mutable _column_family : string option = None
  method get_column_family = _column_family
  method grab_column_family = match _column_family with None->raise (Field_empty "system_drop_column_family_args.column_family") | Some _x603 -> _x603
  method set_column_family _x603 = _column_family <- Some _x603
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_drop_column_family_args";
    (match _column_family with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_family",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_drop_column_family_args (iprot : Protocol.t) =
  let _str606 = new system_drop_column_family_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t607,_id608) = iprot#readFieldBegin in
        if _t607 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id608 with 
          | 1 -> (if _t607 = Protocol.T_STRING then
              _str606#set_column_family iprot#readString
            else
              iprot#skip _t607)
          | _ -> iprot#skip _t607);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str606

class system_drop_column_family_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_drop_column_family_result.success") | Some _x609 -> _x609
  method set_success _x609 = _success <- Some _x609
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_drop_column_family_result.ire") | Some _x609 -> _x609
  method set_ire _x609 = _ire <- Some _x609
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_drop_column_family_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_drop_column_family_result (iprot : Protocol.t) =
  let _str612 = new system_drop_column_family_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t613,_id614) = iprot#readFieldBegin in
        if _t613 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id614 with 
          | 0 -> (if _t613 = Protocol.T_STRING then
              _str612#set_success iprot#readString
            else
              iprot#skip _t613)
          | 1 -> (if _t613 = Protocol.T_STRUCT then
              _str612#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t613)
          | _ -> iprot#skip _t613);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str612

class system_rename_column_family_args =
object (self)
  val mutable _old_name : string option = None
  method get_old_name = _old_name
  method grab_old_name = match _old_name with None->raise (Field_empty "system_rename_column_family_args.old_name") | Some _x615 -> _x615
  method set_old_name _x615 = _old_name <- Some _x615
  val mutable _new_name : string option = None
  method get_new_name = _new_name
  method grab_new_name = match _new_name with None->raise (Field_empty "system_rename_column_family_args.new_name") | Some _x615 -> _x615
  method set_new_name _x615 = _new_name <- Some _x615
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_rename_column_family_args";
    (match _old_name with None -> () | Some _v -> 
      oprot#writeFieldBegin("old_name",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _new_name with None -> () | Some _v -> 
      oprot#writeFieldBegin("new_name",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_rename_column_family_args (iprot : Protocol.t) =
  let _str618 = new system_rename_column_family_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t619,_id620) = iprot#readFieldBegin in
        if _t619 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id620 with 
          | 1 -> (if _t619 = Protocol.T_STRING then
              _str618#set_old_name iprot#readString
            else
              iprot#skip _t619)
          | 2 -> (if _t619 = Protocol.T_STRING then
              _str618#set_new_name iprot#readString
            else
              iprot#skip _t619)
          | _ -> iprot#skip _t619);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str618

class system_rename_column_family_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_rename_column_family_result.success") | Some _x621 -> _x621
  method set_success _x621 = _success <- Some _x621
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_rename_column_family_result.ire") | Some _x621 -> _x621
  method set_ire _x621 = _ire <- Some _x621
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_rename_column_family_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_rename_column_family_result (iprot : Protocol.t) =
  let _str624 = new system_rename_column_family_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t625,_id626) = iprot#readFieldBegin in
        if _t625 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id626 with 
          | 0 -> (if _t625 = Protocol.T_STRING then
              _str624#set_success iprot#readString
            else
              iprot#skip _t625)
          | 1 -> (if _t625 = Protocol.T_STRUCT then
              _str624#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t625)
          | _ -> iprot#skip _t625);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str624

class system_add_keyspace_args =
object (self)
  val mutable _ks_def : ksDef option = None
  method get_ks_def = _ks_def
  method grab_ks_def = match _ks_def with None->raise (Field_empty "system_add_keyspace_args.ks_def") | Some _x627 -> _x627
  method set_ks_def _x627 = _ks_def <- Some _x627
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_add_keyspace_args";
    (match _ks_def with None -> () | Some _v -> 
      oprot#writeFieldBegin("ks_def",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_add_keyspace_args (iprot : Protocol.t) =
  let _str630 = new system_add_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t631,_id632) = iprot#readFieldBegin in
        if _t631 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id632 with 
          | 1 -> (if _t631 = Protocol.T_STRUCT then
              _str630#set_ks_def (read_ksDef iprot)
            else
              iprot#skip _t631)
          | _ -> iprot#skip _t631);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str630

class system_add_keyspace_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_add_keyspace_result.success") | Some _x633 -> _x633
  method set_success _x633 = _success <- Some _x633
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_add_keyspace_result.ire") | Some _x633 -> _x633
  method set_ire _x633 = _ire <- Some _x633
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_add_keyspace_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_add_keyspace_result (iprot : Protocol.t) =
  let _str636 = new system_add_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t637,_id638) = iprot#readFieldBegin in
        if _t637 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id638 with 
          | 0 -> (if _t637 = Protocol.T_STRING then
              _str636#set_success iprot#readString
            else
              iprot#skip _t637)
          | 1 -> (if _t637 = Protocol.T_STRUCT then
              _str636#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t637)
          | _ -> iprot#skip _t637);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str636

class system_drop_keyspace_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "system_drop_keyspace_args.keyspace") | Some _x639 -> _x639
  method set_keyspace _x639 = _keyspace <- Some _x639
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_drop_keyspace_args";
    (match _keyspace with None -> () | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_drop_keyspace_args (iprot : Protocol.t) =
  let _str642 = new system_drop_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t643,_id644) = iprot#readFieldBegin in
        if _t643 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id644 with 
          | 1 -> (if _t643 = Protocol.T_STRING then
              _str642#set_keyspace iprot#readString
            else
              iprot#skip _t643)
          | _ -> iprot#skip _t643);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str642

class system_drop_keyspace_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_drop_keyspace_result.success") | Some _x645 -> _x645
  method set_success _x645 = _success <- Some _x645
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_drop_keyspace_result.ire") | Some _x645 -> _x645
  method set_ire _x645 = _ire <- Some _x645
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_drop_keyspace_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_drop_keyspace_result (iprot : Protocol.t) =
  let _str648 = new system_drop_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t649,_id650) = iprot#readFieldBegin in
        if _t649 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id650 with 
          | 0 -> (if _t649 = Protocol.T_STRING then
              _str648#set_success iprot#readString
            else
              iprot#skip _t649)
          | 1 -> (if _t649 = Protocol.T_STRUCT then
              _str648#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t649)
          | _ -> iprot#skip _t649);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str648

class system_rename_keyspace_args =
object (self)
  val mutable _old_name : string option = None
  method get_old_name = _old_name
  method grab_old_name = match _old_name with None->raise (Field_empty "system_rename_keyspace_args.old_name") | Some _x651 -> _x651
  method set_old_name _x651 = _old_name <- Some _x651
  val mutable _new_name : string option = None
  method get_new_name = _new_name
  method grab_new_name = match _new_name with None->raise (Field_empty "system_rename_keyspace_args.new_name") | Some _x651 -> _x651
  method set_new_name _x651 = _new_name <- Some _x651
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_rename_keyspace_args";
    (match _old_name with None -> () | Some _v -> 
      oprot#writeFieldBegin("old_name",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _new_name with None -> () | Some _v -> 
      oprot#writeFieldBegin("new_name",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_rename_keyspace_args (iprot : Protocol.t) =
  let _str654 = new system_rename_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t655,_id656) = iprot#readFieldBegin in
        if _t655 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id656 with 
          | 1 -> (if _t655 = Protocol.T_STRING then
              _str654#set_old_name iprot#readString
            else
              iprot#skip _t655)
          | 2 -> (if _t655 = Protocol.T_STRING then
              _str654#set_new_name iprot#readString
            else
              iprot#skip _t655)
          | _ -> iprot#skip _t655);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str654

class system_rename_keyspace_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_rename_keyspace_result.success") | Some _x657 -> _x657
  method set_success _x657 = _success <- Some _x657
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_rename_keyspace_result.ire") | Some _x657 -> _x657
  method set_ire _x657 = _ire <- Some _x657
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_rename_keyspace_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_rename_keyspace_result (iprot : Protocol.t) =
  let _str660 = new system_rename_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t661,_id662) = iprot#readFieldBegin in
        if _t661 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id662 with 
          | 0 -> (if _t661 = Protocol.T_STRING then
              _str660#set_success iprot#readString
            else
              iprot#skip _t661)
          | 1 -> (if _t661 = Protocol.T_STRUCT then
              _str660#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t661)
          | _ -> iprot#skip _t661);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str660

class virtual iface =
object (self)
  method virtual login : authenticationRequest option -> AccessLevel.t
  method virtual set_keyspace : string option -> unit
  method virtual get : string option -> columnPath option -> ConsistencyLevel.t option -> columnOrSuperColumn
  method virtual get_slice : string option -> columnParent option -> slicePredicate option -> ConsistencyLevel.t option -> columnOrSuperColumn list
  method virtual get_count : string option -> columnParent option -> slicePredicate option -> ConsistencyLevel.t option -> int
  method virtual multiget_slice : string list option -> columnParent option -> slicePredicate option -> ConsistencyLevel.t option -> (string,columnOrSuperColumn list) Hashtbl.t
  method virtual multiget_count : string option -> string list option -> columnParent option -> slicePredicate option -> ConsistencyLevel.t option -> (string,int) Hashtbl.t
  method virtual get_range_slices : columnParent option -> slicePredicate option -> keyRange option -> ConsistencyLevel.t option -> keySlice list
  method virtual get_indexed_slices : columnParent option -> indexClause option -> slicePredicate option -> ConsistencyLevel.t option -> keySlice list
  method virtual insert : string option -> columnParent option -> column option -> ConsistencyLevel.t option -> unit
  method virtual remove : string option -> columnPath option -> clock option -> ConsistencyLevel.t option -> unit
  method virtual batch_mutate : (string,(string,mutation list) Hashtbl.t) Hashtbl.t option -> ConsistencyLevel.t option -> unit
  method virtual truncate : string option -> unit
  method virtual check_schema_agreement : (string,string list) Hashtbl.t
  method virtual describe_keyspaces : ksDef list
  method virtual describe_cluster_name : string
  method virtual describe_version : string
  method virtual describe_ring : string option -> tokenRange list
  method virtual describe_partitioner : string
  method virtual describe_keyspace : string option -> ksDef
  method virtual describe_splits : string option -> string option -> string option -> string option -> int option -> string list
  method virtual system_add_column_family : cfDef option -> string
  method virtual system_drop_column_family : string option -> string
  method virtual system_rename_column_family : string option -> string option -> string
  method virtual system_add_keyspace : ksDef option -> string
  method virtual system_drop_keyspace : string option -> string
  method virtual system_rename_keyspace : string option -> string option -> string
end

class client (iprot : Protocol.t) (oprot : Protocol.t) =
object (self)
  val mutable seqid = 0
  method login auth_request = 
    self#send_login auth_request;
    self#recv_login
  method private send_login auth_request = 
    oprot#writeMessageBegin ("login", Protocol.CALL, seqid);
    let args = new login_args in
      args#set_auth_request auth_request;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_login  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_login_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_authnx with None -> () | Some _v ->
            raise (AuthenticationException _v));
          (match result#get_authzx with None -> () | Some _v ->
            raise (AuthorizationException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "login failed: unknown result")))
  method set_keyspace keyspace = 
    self#send_set_keyspace keyspace;
    self#recv_set_keyspace
  method private send_set_keyspace keyspace = 
    oprot#writeMessageBegin ("set_keyspace", Protocol.CALL, seqid);
    let args = new set_keyspace_args in
      args#set_keyspace keyspace;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_set_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_set_keyspace_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        ()
  method get key column_path consistency_level = 
    self#send_get key column_path consistency_level;
    self#recv_get
  method private send_get key column_path consistency_level = 
    oprot#writeMessageBegin ("get", Protocol.CALL, seqid);
    let args = new get_args in
      args#set_key key;
      args#set_column_path column_path;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_nfe with None -> () | Some _v ->
            raise (NotFoundException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get failed: unknown result")))
  method get_slice key column_parent predicate consistency_level = 
    self#send_get_slice key column_parent predicate consistency_level;
    self#recv_get_slice
  method private send_get_slice key column_parent predicate consistency_level = 
    oprot#writeMessageBegin ("get_slice", Protocol.CALL, seqid);
    let args = new get_slice_args in
      args#set_key key;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_slice  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_slice_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_slice failed: unknown result")))
  method get_count key column_parent predicate consistency_level = 
    self#send_get_count key column_parent predicate consistency_level;
    self#recv_get_count
  method private send_get_count key column_parent predicate consistency_level = 
    oprot#writeMessageBegin ("get_count", Protocol.CALL, seqid);
    let args = new get_count_args in
      args#set_key key;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_count  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_count_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_count failed: unknown result")))
  method multiget_slice keys column_parent predicate consistency_level = 
    self#send_multiget_slice keys column_parent predicate consistency_level;
    self#recv_multiget_slice
  method private send_multiget_slice keys column_parent predicate consistency_level = 
    oprot#writeMessageBegin ("multiget_slice", Protocol.CALL, seqid);
    let args = new multiget_slice_args in
      args#set_keys keys;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_multiget_slice  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_multiget_slice_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "multiget_slice failed: unknown result")))
  method multiget_count keyspace keys column_parent predicate consistency_level = 
    self#send_multiget_count keyspace keys column_parent predicate consistency_level;
    self#recv_multiget_count
  method private send_multiget_count keyspace keys column_parent predicate consistency_level = 
    oprot#writeMessageBegin ("multiget_count", Protocol.CALL, seqid);
    let args = new multiget_count_args in
      args#set_keyspace keyspace;
      args#set_keys keys;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_multiget_count  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_multiget_count_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "multiget_count failed: unknown result")))
  method get_range_slices column_parent predicate range consistency_level = 
    self#send_get_range_slices column_parent predicate range consistency_level;
    self#recv_get_range_slices
  method private send_get_range_slices column_parent predicate range consistency_level = 
    oprot#writeMessageBegin ("get_range_slices", Protocol.CALL, seqid);
    let args = new get_range_slices_args in
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_range range;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_range_slices  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_range_slices_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_range_slices failed: unknown result")))
  method get_indexed_slices column_parent index_clause column_predicate consistency_level = 
    self#send_get_indexed_slices column_parent index_clause column_predicate consistency_level;
    self#recv_get_indexed_slices
  method private send_get_indexed_slices column_parent index_clause column_predicate consistency_level = 
    oprot#writeMessageBegin ("get_indexed_slices", Protocol.CALL, seqid);
    let args = new get_indexed_slices_args in
      args#set_column_parent column_parent;
      args#set_index_clause index_clause;
      args#set_column_predicate column_predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_indexed_slices  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_indexed_slices_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_indexed_slices failed: unknown result")))
  method insert key column_parent column consistency_level = 
    self#send_insert key column_parent column consistency_level;
    self#recv_insert
  method private send_insert key column_parent column consistency_level = 
    oprot#writeMessageBegin ("insert", Protocol.CALL, seqid);
    let args = new insert_args in
      args#set_key key;
      args#set_column_parent column_parent;
      args#set_column column;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_insert  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_insert_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method remove key column_path clock consistency_level = 
    self#send_remove key column_path clock consistency_level;
    self#recv_remove
  method private send_remove key column_path clock consistency_level = 
    oprot#writeMessageBegin ("remove", Protocol.CALL, seqid);
    let args = new remove_args in
      args#set_key key;
      args#set_column_path column_path;
      args#set_clock clock;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_remove  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_remove_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method batch_mutate mutation_map consistency_level = 
    self#send_batch_mutate mutation_map consistency_level;
    self#recv_batch_mutate
  method private send_batch_mutate mutation_map consistency_level = 
    oprot#writeMessageBegin ("batch_mutate", Protocol.CALL, seqid);
    let args = new batch_mutate_args in
      args#set_mutation_map mutation_map;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_batch_mutate  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_batch_mutate_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method truncate cfname = 
    self#send_truncate cfname;
    self#recv_truncate
  method private send_truncate cfname = 
    oprot#writeMessageBegin ("truncate", Protocol.CALL, seqid);
    let args = new truncate_args in
      args#set_cfname cfname;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_truncate  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_truncate_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        ()
  method check_schema_agreement  = 
    self#send_check_schema_agreement;
    self#recv_check_schema_agreement
  method private send_check_schema_agreement  = 
    oprot#writeMessageBegin ("check_schema_agreement", Protocol.CALL, seqid);
    let args = new check_schema_agreement_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_check_schema_agreement  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_check_schema_agreement_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "check_schema_agreement failed: unknown result")))
  method describe_keyspaces  = 
    self#send_describe_keyspaces;
    self#recv_describe_keyspaces
  method private send_describe_keyspaces  = 
    oprot#writeMessageBegin ("describe_keyspaces", Protocol.CALL, seqid);
    let args = new describe_keyspaces_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_keyspaces  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_keyspaces_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_keyspaces failed: unknown result")))
  method describe_cluster_name  = 
    self#send_describe_cluster_name;
    self#recv_describe_cluster_name
  method private send_describe_cluster_name  = 
    oprot#writeMessageBegin ("describe_cluster_name", Protocol.CALL, seqid);
    let args = new describe_cluster_name_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_cluster_name  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_cluster_name_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_cluster_name failed: unknown result")))
  method describe_version  = 
    self#send_describe_version;
    self#recv_describe_version
  method private send_describe_version  = 
    oprot#writeMessageBegin ("describe_version", Protocol.CALL, seqid);
    let args = new describe_version_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_version  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_version_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_version failed: unknown result")))
  method describe_ring keyspace = 
    self#send_describe_ring keyspace;
    self#recv_describe_ring
  method private send_describe_ring keyspace = 
    oprot#writeMessageBegin ("describe_ring", Protocol.CALL, seqid);
    let args = new describe_ring_args in
      args#set_keyspace keyspace;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_ring  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_ring_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_ring failed: unknown result")))
  method describe_partitioner  = 
    self#send_describe_partitioner;
    self#recv_describe_partitioner
  method private send_describe_partitioner  = 
    oprot#writeMessageBegin ("describe_partitioner", Protocol.CALL, seqid);
    let args = new describe_partitioner_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_partitioner  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_partitioner_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_partitioner failed: unknown result")))
  method describe_keyspace keyspace = 
    self#send_describe_keyspace keyspace;
    self#recv_describe_keyspace
  method private send_describe_keyspace keyspace = 
    oprot#writeMessageBegin ("describe_keyspace", Protocol.CALL, seqid);
    let args = new describe_keyspace_args in
      args#set_keyspace keyspace;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_keyspace_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_nfe with None -> () | Some _v ->
            raise (NotFoundException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_keyspace failed: unknown result")))
  method describe_splits keyspace cfName start_token end_token keys_per_split = 
    self#send_describe_splits keyspace cfName start_token end_token keys_per_split;
    self#recv_describe_splits
  method private send_describe_splits keyspace cfName start_token end_token keys_per_split = 
    oprot#writeMessageBegin ("describe_splits", Protocol.CALL, seqid);
    let args = new describe_splits_args in
      args#set_keyspace keyspace;
      args#set_cfName cfName;
      args#set_start_token start_token;
      args#set_end_token end_token;
      args#set_keys_per_split keys_per_split;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_splits  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_splits_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_splits failed: unknown result")))
  method system_add_column_family cf_def = 
    self#send_system_add_column_family cf_def;
    self#recv_system_add_column_family
  method private send_system_add_column_family cf_def = 
    oprot#writeMessageBegin ("system_add_column_family", Protocol.CALL, seqid);
    let args = new system_add_column_family_args in
      args#set_cf_def cf_def;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_add_column_family  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_add_column_family_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_add_column_family failed: unknown result")))
  method system_drop_column_family column_family = 
    self#send_system_drop_column_family column_family;
    self#recv_system_drop_column_family
  method private send_system_drop_column_family column_family = 
    oprot#writeMessageBegin ("system_drop_column_family", Protocol.CALL, seqid);
    let args = new system_drop_column_family_args in
      args#set_column_family column_family;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_drop_column_family  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_drop_column_family_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_drop_column_family failed: unknown result")))
  method system_rename_column_family old_name new_name = 
    self#send_system_rename_column_family old_name new_name;
    self#recv_system_rename_column_family
  method private send_system_rename_column_family old_name new_name = 
    oprot#writeMessageBegin ("system_rename_column_family", Protocol.CALL, seqid);
    let args = new system_rename_column_family_args in
      args#set_old_name old_name;
      args#set_new_name new_name;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_rename_column_family  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_rename_column_family_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_rename_column_family failed: unknown result")))
  method system_add_keyspace ks_def = 
    self#send_system_add_keyspace ks_def;
    self#recv_system_add_keyspace
  method private send_system_add_keyspace ks_def = 
    oprot#writeMessageBegin ("system_add_keyspace", Protocol.CALL, seqid);
    let args = new system_add_keyspace_args in
      args#set_ks_def ks_def;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_add_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_add_keyspace_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_add_keyspace failed: unknown result")))
  method system_drop_keyspace keyspace = 
    self#send_system_drop_keyspace keyspace;
    self#recv_system_drop_keyspace
  method private send_system_drop_keyspace keyspace = 
    oprot#writeMessageBegin ("system_drop_keyspace", Protocol.CALL, seqid);
    let args = new system_drop_keyspace_args in
      args#set_keyspace keyspace;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_drop_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_drop_keyspace_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_drop_keyspace failed: unknown result")))
  method system_rename_keyspace old_name new_name = 
    self#send_system_rename_keyspace old_name new_name;
    self#recv_system_rename_keyspace
  method private send_system_rename_keyspace old_name new_name = 
    oprot#writeMessageBegin ("system_rename_keyspace", Protocol.CALL, seqid);
    let args = new system_rename_keyspace_args in
      args#set_old_name old_name;
      args#set_new_name new_name;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_rename_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_rename_keyspace_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_rename_keyspace failed: unknown result")))
end

class processor (handler : iface) =
object (self)
  inherit Processor.t

  val processMap = Hashtbl.create 27
  method process iprot oprot =
    let (name, typ, seqid)  = iprot#readMessageBegin in
      if Hashtbl.mem processMap name then
        (Hashtbl.find processMap name) (seqid, iprot, oprot)
      else (
        iprot#skip(Protocol.T_STRUCT);
        iprot#readMessageEnd;
        let x = Application_Exn.create Application_Exn.UNKNOWN_METHOD ("Unknown function "^name) in
          oprot#writeMessageBegin(name, Protocol.EXCEPTION, seqid);
          x#write oprot;
          oprot#writeMessageEnd;
          oprot#getTransport#flush
      );
      true
  method private process_login (seqid, iprot, oprot) =
    let args = read_login_args iprot in
      iprot#readMessageEnd;
      let result = new login_result in
        (try
          result#set_success (handler#login args#get_auth_request);
        with
          | AuthenticationException authnx -> 
              result#set_authnx authnx
          | AuthorizationException authzx -> 
              result#set_authzx authzx
        );
        oprot#writeMessageBegin ("login", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_set_keyspace (seqid, iprot, oprot) =
    let args = read_set_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new set_keyspace_result in
        (try
          (handler#set_keyspace args#get_keyspace);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("set_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get (seqid, iprot, oprot) =
    let args = read_get_args iprot in
      iprot#readMessageEnd;
      let result = new get_result in
        (try
          result#set_success (handler#get args#get_key args#get_column_path args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | NotFoundException nfe -> 
              result#set_nfe nfe
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_slice (seqid, iprot, oprot) =
    let args = read_get_slice_args iprot in
      iprot#readMessageEnd;
      let result = new get_slice_result in
        (try
          result#set_success (handler#get_slice args#get_key args#get_column_parent args#get_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_slice", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_count (seqid, iprot, oprot) =
    let args = read_get_count_args iprot in
      iprot#readMessageEnd;
      let result = new get_count_result in
        (try
          result#set_success (handler#get_count args#get_key args#get_column_parent args#get_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_count", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_multiget_slice (seqid, iprot, oprot) =
    let args = read_multiget_slice_args iprot in
      iprot#readMessageEnd;
      let result = new multiget_slice_result in
        (try
          result#set_success (handler#multiget_slice args#get_keys args#get_column_parent args#get_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("multiget_slice", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_multiget_count (seqid, iprot, oprot) =
    let args = read_multiget_count_args iprot in
      iprot#readMessageEnd;
      let result = new multiget_count_result in
        (try
          result#set_success (handler#multiget_count args#get_keyspace args#get_keys args#get_column_parent args#get_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("multiget_count", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_range_slices (seqid, iprot, oprot) =
    let args = read_get_range_slices_args iprot in
      iprot#readMessageEnd;
      let result = new get_range_slices_result in
        (try
          result#set_success (handler#get_range_slices args#get_column_parent args#get_predicate args#get_range args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_range_slices", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_indexed_slices (seqid, iprot, oprot) =
    let args = read_get_indexed_slices_args iprot in
      iprot#readMessageEnd;
      let result = new get_indexed_slices_result in
        (try
          result#set_success (handler#get_indexed_slices args#get_column_parent args#get_index_clause args#get_column_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_indexed_slices", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_insert (seqid, iprot, oprot) =
    let args = read_insert_args iprot in
      iprot#readMessageEnd;
      let result = new insert_result in
        (try
          (handler#insert args#get_key args#get_column_parent args#get_column args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("insert", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_remove (seqid, iprot, oprot) =
    let args = read_remove_args iprot in
      iprot#readMessageEnd;
      let result = new remove_result in
        (try
          (handler#remove args#get_key args#get_column_path args#get_clock args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("remove", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_batch_mutate (seqid, iprot, oprot) =
    let args = read_batch_mutate_args iprot in
      iprot#readMessageEnd;
      let result = new batch_mutate_result in
        (try
          (handler#batch_mutate args#get_mutation_map args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("batch_mutate", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_truncate (seqid, iprot, oprot) =
    let args = read_truncate_args iprot in
      iprot#readMessageEnd;
      let result = new truncate_result in
        (try
          (handler#truncate args#get_cfname);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
        );
        oprot#writeMessageBegin ("truncate", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_check_schema_agreement (seqid, iprot, oprot) =
    let _ = read_check_schema_agreement_args iprot in
      iprot#readMessageEnd;
      let result = new check_schema_agreement_result in
        (try
          result#set_success (handler#check_schema_agreement);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("check_schema_agreement", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_keyspaces (seqid, iprot, oprot) =
    let _ = read_describe_keyspaces_args iprot in
      iprot#readMessageEnd;
      let result = new describe_keyspaces_result in
        result#set_success (handler#describe_keyspaces);
        oprot#writeMessageBegin ("describe_keyspaces", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_cluster_name (seqid, iprot, oprot) =
    let _ = read_describe_cluster_name_args iprot in
      iprot#readMessageEnd;
      let result = new describe_cluster_name_result in
        result#set_success (handler#describe_cluster_name);
        oprot#writeMessageBegin ("describe_cluster_name", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_version (seqid, iprot, oprot) =
    let _ = read_describe_version_args iprot in
      iprot#readMessageEnd;
      let result = new describe_version_result in
        result#set_success (handler#describe_version);
        oprot#writeMessageBegin ("describe_version", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_ring (seqid, iprot, oprot) =
    let args = read_describe_ring_args iprot in
      iprot#readMessageEnd;
      let result = new describe_ring_result in
        (try
          result#set_success (handler#describe_ring args#get_keyspace);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("describe_ring", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_partitioner (seqid, iprot, oprot) =
    let _ = read_describe_partitioner_args iprot in
      iprot#readMessageEnd;
      let result = new describe_partitioner_result in
        result#set_success (handler#describe_partitioner);
        oprot#writeMessageBegin ("describe_partitioner", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_keyspace (seqid, iprot, oprot) =
    let args = read_describe_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new describe_keyspace_result in
        (try
          result#set_success (handler#describe_keyspace args#get_keyspace);
        with
          | NotFoundException nfe -> 
              result#set_nfe nfe
        );
        oprot#writeMessageBegin ("describe_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_splits (seqid, iprot, oprot) =
    let args = read_describe_splits_args iprot in
      iprot#readMessageEnd;
      let result = new describe_splits_result in
        result#set_success (handler#describe_splits args#get_keyspace args#get_cfName args#get_start_token args#get_end_token args#get_keys_per_split);
        oprot#writeMessageBegin ("describe_splits", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_add_column_family (seqid, iprot, oprot) =
    let args = read_system_add_column_family_args iprot in
      iprot#readMessageEnd;
      let result = new system_add_column_family_result in
        (try
          result#set_success (handler#system_add_column_family args#get_cf_def);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("system_add_column_family", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_drop_column_family (seqid, iprot, oprot) =
    let args = read_system_drop_column_family_args iprot in
      iprot#readMessageEnd;
      let result = new system_drop_column_family_result in
        (try
          result#set_success (handler#system_drop_column_family args#get_column_family);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("system_drop_column_family", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_rename_column_family (seqid, iprot, oprot) =
    let args = read_system_rename_column_family_args iprot in
      iprot#readMessageEnd;
      let result = new system_rename_column_family_result in
        (try
          result#set_success (handler#system_rename_column_family args#get_old_name args#get_new_name);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("system_rename_column_family", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_add_keyspace (seqid, iprot, oprot) =
    let args = read_system_add_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new system_add_keyspace_result in
        (try
          result#set_success (handler#system_add_keyspace args#get_ks_def);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("system_add_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_drop_keyspace (seqid, iprot, oprot) =
    let args = read_system_drop_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new system_drop_keyspace_result in
        (try
          result#set_success (handler#system_drop_keyspace args#get_keyspace);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("system_drop_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_rename_keyspace (seqid, iprot, oprot) =
    let args = read_system_rename_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new system_rename_keyspace_result in
        (try
          result#set_success (handler#system_rename_keyspace args#get_old_name args#get_new_name);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("system_rename_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  initializer
    Hashtbl.add processMap "login" self#process_login;
    Hashtbl.add processMap "set_keyspace" self#process_set_keyspace;
    Hashtbl.add processMap "get" self#process_get;
    Hashtbl.add processMap "get_slice" self#process_get_slice;
    Hashtbl.add processMap "get_count" self#process_get_count;
    Hashtbl.add processMap "multiget_slice" self#process_multiget_slice;
    Hashtbl.add processMap "multiget_count" self#process_multiget_count;
    Hashtbl.add processMap "get_range_slices" self#process_get_range_slices;
    Hashtbl.add processMap "get_indexed_slices" self#process_get_indexed_slices;
    Hashtbl.add processMap "insert" self#process_insert;
    Hashtbl.add processMap "remove" self#process_remove;
    Hashtbl.add processMap "batch_mutate" self#process_batch_mutate;
    Hashtbl.add processMap "truncate" self#process_truncate;
    Hashtbl.add processMap "check_schema_agreement" self#process_check_schema_agreement;
    Hashtbl.add processMap "describe_keyspaces" self#process_describe_keyspaces;
    Hashtbl.add processMap "describe_cluster_name" self#process_describe_cluster_name;
    Hashtbl.add processMap "describe_version" self#process_describe_version;
    Hashtbl.add processMap "describe_ring" self#process_describe_ring;
    Hashtbl.add processMap "describe_partitioner" self#process_describe_partitioner;
    Hashtbl.add processMap "describe_keyspace" self#process_describe_keyspace;
    Hashtbl.add processMap "describe_splits" self#process_describe_splits;
    Hashtbl.add processMap "system_add_column_family" self#process_system_add_column_family;
    Hashtbl.add processMap "system_drop_column_family" self#process_system_drop_column_family;
    Hashtbl.add processMap "system_rename_column_family" self#process_system_rename_column_family;
    Hashtbl.add processMap "system_add_keyspace" self#process_system_add_keyspace;
    Hashtbl.add processMap "system_drop_keyspace" self#process_system_drop_keyspace;
    Hashtbl.add processMap "system_rename_keyspace" self#process_system_rename_keyspace;
end

